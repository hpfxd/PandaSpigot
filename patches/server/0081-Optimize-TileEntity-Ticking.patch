From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: mechoriet <kevinworm92@gmail.com>
Date: Sun, 20 Nov 2022 12:11:36 +0100
Subject: [PATCH] Optimize TileEntity Ticking

Re-organizes the servers TileEntity Tick List to be bucketed based on their tick interval.

We now will not even store a Tile Entity that is known to not have any tick function
(half of them), skipping time spent iterating them and checking if they are valid
and in a loaded chunk. In other words, a lot of "meta" time wasted on tile entities
that would never do anything anyways.

Then by reducing chests to 1 in 20 ticks, we cut out 95% of isLoaded checks and findPlayer
calls on chests, and 100% of the checks for Signs, the 2 most popular Tile Entities.

This cuts out a massive amount of checks revolving around TileEntity ticking.
Servers with large amounts of TileEntities should see significant improvement.

Finally, this then spreads out the ticking of reduced-rate TileEntities so that they
do not all tick on the same tick, distributing the load of some TileEntities like Chest.

diff --git a/src/main/java/com/hpfxd/pandaspigot/lists/WorldTileEntityList.java b/src/main/java/com/hpfxd/pandaspigot/lists/WorldTileEntityList.java
new file mode 100644
index 0000000000000000000000000000000000000000..7165a1f836d3f059dfd607b0f55631e89df4704a
--- /dev/null
+++ b/src/main/java/com/hpfxd/pandaspigot/lists/WorldTileEntityList.java
@@ -0,0 +1,173 @@
+package com.hpfxd.pandaspigot.lists;
+
+
+import gnu.trove.map.hash.TObjectIntHashMap;
+import net.minecraft.server.*;
+import java.util.HashSet;
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Map;
+public class WorldTileEntityList extends HashSet<TileEntity> {
+    private static final TObjectIntHashMap<Class<? extends TileEntity>> tileEntityTickIntervals =
+        new TObjectIntHashMap<>();
+
+    private static int getInterval(Class<? extends TileEntity> cls) {
+        int tickInterval = tileEntityTickIntervals.get(cls);
+        return tickInterval != 0 ? tickInterval : 1;
+    }
+
+    private static int getBucketId(TileEntity entity, Integer interval) {
+        return entity.tileId % interval;
+    }
+
+    private final Map<Integer, Multimap<Integer, TileEntity>> tickList = Maps.newHashMap();
+    private final WorldServer world;
+
+    public WorldTileEntityList(World world) {
+        this.world = (WorldServer) world;
+        // Use -1 for no ticking
+        // These TE's have empty tick methods, doing nothing. Never bother ticking them.
+        for (Class<? extends TileEntity> ignored : new Class[]{
+            TileEntityChest.class, // PaperSpigot - Don't tick chests either
+            TileEntityEnderChest.class, // PaperSpigot - Don't tick chests either
+            BlockJukeBox.TileEntityRecordPlayer.class,
+            TileEntityDispenser.class,
+            TileEntityDropper.class,
+            TileEntitySign.class,
+            TileEntityNote.class,
+            TileEntityEnderPortal.class,
+            TileEntityCommand.class,
+            TileEntitySkull.class,
+            TileEntityComparator.class,
+            TileEntityFlowerPot.class
+        }) {
+            tileEntityTickIntervals.put(ignored, -1);
+        }
+
+        // does findPlayer lookup, so this helps performance to slow down
+        tileEntityTickIntervals.put(TileEntityEnchantTable.class, 20);
+
+        // Slow things down that players won't notice due to craftbukkit "wall time" patches.
+        // These need to be investigated further before they can be safely used here
+        //put(TileEntityFurnace.class, 20);
+        //put(TileEntityBrewingStand.class, 10);
+
+        // Vanilla controlled values - These are checks already done in vanilla, so don't tick on ticks we know
+        // won't do anything anyways
+        tileEntityTickIntervals.put(TileEntityBeacon.class, 80);
+        tileEntityTickIntervals.put(TileEntityLightDetector.class, 20);
+    }
+
+
+    private Multimap<Integer, TileEntity> getBucket(int interval) {
+        Multimap<Integer, TileEntity> intervalBucket = tickList.get(interval);
+        if (intervalBucket == null) {
+            intervalBucket = ArrayListMultimap.create();
+            tickList.put(interval, intervalBucket);
+        }
+        return intervalBucket;
+    }
+
+    /**
+     * Adds the TileEntity to the tick list only if it is expected to tick
+     */
+    @Override
+    public boolean add(TileEntity entity) {
+            if (entity.isAdded) {
+                return false;
+            }
+
+            int interval = getInterval(entity.getClass());
+            if (interval > 0) {
+                entity.isAdded = true;
+                int bucket = getBucketId(entity, interval);
+                Multimap<Integer, TileEntity> typeBucket = getBucket(interval);
+                return typeBucket.put(bucket, entity);
+            }
+            return false;
+        }
+
+        @Override
+    public boolean remove(Object o) {
+            if (!(o instanceof TileEntity)) {
+                return false;
+            }
+            TileEntity entity = (TileEntity) o;
+            if (!entity.isAdded) {
+                return false;
+            }
+            entity.isAdded = false;
+            int interval = getInterval(entity.getClass());
+            int bucket = getBucketId(entity, interval);
+            Multimap<Integer, TileEntity> typeBucket = getBucket(interval);
+            return typeBucket.remove(bucket, entity);
+        }
+
+        @Override
+    public Iterator iterator() {
+            return new WorldTileEntityIterator();
+        }
+
+        @Override
+    public boolean contains(Object o) {
+            return o instanceof TileEntity && ((TileEntity) o).isAdded;
+        }
+
+        private class WorldTileEntityIterator implements Iterator<TileEntity> {
+        private final Iterator<Map.Entry<Integer, Multimap<Integer, TileEntity>>> intervalIterator;
+        private Map.Entry<Integer, Multimap<Integer, TileEntity>> intervalMap = null;
+        private Iterator<TileEntity> listIterator = null;
+
+            protected WorldTileEntityIterator() {
+                    intervalIterator = tickList.entrySet().iterator();
+                    nextInterval();
+                }
+
+            private boolean nextInterval() {
+                    listIterator = null;
+                    if (intervalIterator.hasNext()) {
+                            intervalMap = intervalIterator.next();
+
+                               final Integer interval = intervalMap.getKey();
+                            final Multimap<Integer, TileEntity> buckets = intervalMap.getValue();
+
+                    int bucket = (int) (world.getTime() % interval);
+
+                    if (!buckets.isEmpty() && buckets.containsKey(bucket)) {
+                        final Collection<TileEntity> tileList = buckets.get(bucket);
+
+                            if (tileList != null && !tileList.isEmpty()) {
+                                listIterator = tileList.iterator();
+                                return true;
+                            }
+                    }
+            }
+
+            return false;
+
+             }
+
+       @Override
+  public boolean hasNext() {
+          do {
+             if (listIterator != null && listIterator.hasNext()) {
+                   return true;
+               }
+       } while (nextInterval());
+          return false;
+      }
+
+      @Override
+        public TileEntity next() {
+                    return listIterator.next();
+               }
+
+            @Override
+        public void remove() {
+                    listIterator.remove();
+                }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index f68b132fb9d0b38f2ebc1e4c8c4ca6ef993fc72a..df3e664c277018c7849a5b1c2ef45530612039f4 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -22,6 +22,10 @@ public abstract class TileEntity {
     protected boolean d;
     private int h;
     protected Block e;
+    // Optimized TileEntity Tick changes
+    private static int tileEntityCounter = 0;
+    public boolean isAdded = false;
+    public int tileId = tileEntityCounter++;
 
     public TileEntity() {
         this.position = BlockPosition.ZERO;
diff --git a/src/main/java/net/minecraft/server/TileEntityBeacon.java b/src/main/java/net/minecraft/server/TileEntityBeacon.java
index f4717af7d1a430dab45c5c8c368fd26c4fd73cb2..7094995b801bcdc3ce17f27ff0359cc9a0e5d08c 100644
--- a/src/main/java/net/minecraft/server/TileEntityBeacon.java
+++ b/src/main/java/net/minecraft/server/TileEntityBeacon.java
@@ -56,7 +56,7 @@ public class TileEntityBeacon extends TileEntityContainer implements IUpdatePlay
     public TileEntityBeacon() {}
 
     public void c() {
-        if (this.world.getTime() % 80L == 0L) {
+        if (true || this.world.getTime() % 80L == 0L) { // PandaSpigot - controlled by Improved Tick handling
             this.m();
         }
 
diff --git a/src/main/java/net/minecraft/server/TileEntityLightDetector.java b/src/main/java/net/minecraft/server/TileEntityLightDetector.java
index f75e2de63e96019b3210db14f036fd74353ddcce..8aa7688939a61351c59bdfb14cf61dc1a3f87c86 100644
--- a/src/main/java/net/minecraft/server/TileEntityLightDetector.java
+++ b/src/main/java/net/minecraft/server/TileEntityLightDetector.java
@@ -5,7 +5,7 @@ public class TileEntityLightDetector extends TileEntity implements IUpdatePlayer
     public TileEntityLightDetector() {}
 
     public void c() {
-        if (this.world != null && !this.world.isClientSide && this.world.getTime() % 20L == 0L) {
+        if (this.world != null && !this.world.isClientSide /*&& this.world.getTime() % 20L == 0L*/) { // PaperSpigot - interval controlled by Improved Tick Handling
             this.e = this.w();
             if (this.e instanceof BlockDaylightDetector) {
                 ((BlockDaylightDetector) this.e).f(this.world, this.position);
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 323f33bcdc1b4aae449c4e1c9e4b5a8709376b36..55599331492b78c68aa223bce604d38c63feb584 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -65,7 +65,7 @@ public abstract class World implements IBlockAccess {
     //public final List<TileEntity> h = Lists.newArrayList(); // PaperSpigot - Remove unused list
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
-    private final Set<TileEntity> c = Sets.newHashSet(); // Paper
+    private final Set<TileEntity> c = new com.hpfxd.pandaspigot.lists.WorldTileEntityList(this);; // Paper
     public final List<EntityHuman> players = Lists.newArrayList();
     public final List<Entity> k = Lists.newArrayList();
     protected final IntHashMap<Entity> entitiesById = new IntHashMap();
@@ -1370,7 +1370,7 @@ public abstract class World implements IBlockAccess {
 
         if (entity instanceof EntityItem) return arraylist; // PaperSpigot - Optimize item movement
 
-        double d0 = 0.25D;
+        /*double d0 = 0.25D;
         List list = this.getEntities(entity, axisalignedbb.grow(d0, d0, d0));
 
         for (int j2 = 0; j2 < list.size(); ++j2) {
@@ -1386,7 +1386,7 @@ public abstract class World implements IBlockAccess {
                     arraylist.add(axisalignedbb1);
                 }
             }
-        }
+        }*/
 
         return arraylist;
     }
