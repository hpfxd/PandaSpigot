From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: hpfxd <me@hpfxd.com>
Date: Fri, 29 Oct 2021 06:38:18 -0400
Subject: [PATCH] Optimize Network Manager and add advanced packet support

Adds ability for 1 packet to bundle other packets to follow it
Adds ability for a packet to delay sending more packets until a state is ready.

Removes synchronization from sending packets
Removes processing packet queue off of main thread
  - for the few cases where it is allowed, order is not necessary nor
    should it even be happening concurrently in first place (handshaking/login/status)

Ensures packets sent asynchronously are dispatched on main thread

This helps ensure safety for ProtocolLib as packet listeners
are commonly accessing world state. This will allow you to schedule
a packet to be sent async, but itll be dispatched sync for packet
listeners to process.

This should solve some deadlock risks

Also adds Netty Channel Flush Consolidation to reduce the amount of flushing

Also avoids spamming closed channel exception by rechecking closed state in dispatch
and then catch exceptions and close if they fire.

diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 8f8b9aa731f2c97a3e32369bfd4d641a1f2ab412..f6e797f712f029a9bbe94739469c7464cdb7ed19 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -62,7 +62,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     };
     private final EnumProtocolDirection h;
     private final Queue<NetworkManager.QueuedPacket> i = Queues.newConcurrentLinkedQueue();
-    private final ReentrantReadWriteLock j = new ReentrantReadWriteLock();
+    //private final ReentrantReadWriteLock j = new ReentrantReadWriteLock(); // PandaSpigot - Remove packet queue locking
     public Channel channel;
     // Spigot Start // PAIL
     public SocketAddress l;
@@ -75,6 +75,11 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     private boolean o;
     private boolean p;
     private static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush"); // PandaSpigot - Disable explicit flushing
+    // PandaSpigot start - Optimize network
+    public boolean isPending = true;
+    public boolean queueImmunity = false;
+    public EnumProtocol protocol;
+    // PandaSpigot end
 
     public NetworkManager(EnumProtocolDirection enumprotocoldirection) {
         this.h = enumprotocoldirection;
@@ -97,6 +102,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     }
 
     public void a(EnumProtocol enumprotocol) {
+        this.protocol = enumprotocol; // PandaSpigot
         this.channel.attr(NetworkManager.c).set(enumprotocol);
         this.channel.config().setAutoRead(true);
         NetworkManager.g.debug("Enabled auto read");
@@ -135,39 +141,93 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         NetworkManager.g.debug("Set listener of {} to {}", new Object[] { this, packetlistener});
         this.m = packetlistener;
     }
-
-    public void handle(Packet packet) {
-        if (this.g()) {
-            this.m();
-            this.a(packet, (GenericFutureListener[]) null);
+    // PandaSpigot start
+    public EntityPlayer getPlayer() {
+        if (this.m instanceof PlayerConnection) {
+            return ((PlayerConnection) this.m).player;
         } else {
-            this.j.writeLock().lock();
-
-            try {
-                this.i.add(new NetworkManager.QueuedPacket(packet, (GenericFutureListener[]) null));
-            } finally {
-                this.j.writeLock().unlock();
+            return null;
+        }
+    }
+    private static class InnerUtil { // Attempt to hide these methods from ProtocolLib, so it doesn't accidentally pick them up.
+        private static java.util.List<Packet> buildExtraPackets(Packet packet) {
+            java.util.List<Packet> extra = packet.getExtraPackets();
+            if (extra == null || extra.isEmpty()) {
+                return null;
             }
+            java.util.List<Packet> ret = new java.util.ArrayList<>(1 + extra.size());
+            buildExtraPackets0(extra, ret);
+            return ret;
         }
+        
+        private static void buildExtraPackets0(java.util.List<Packet> extraPackets, java.util.List<Packet> into) {
+            for (Packet extra : extraPackets) {
+                into.add(extra);
+                java.util.List<Packet> extraExtra = extra.getExtraPackets();
+                if (extraExtra != null && !extraExtra.isEmpty()) {
+                    buildExtraPackets0(extraExtra, into);
+                }
+            }
+        }
+        
+        private static boolean canSendImmediate(NetworkManager networkManager, Packet<?> packet) {
+            return networkManager.isPending || networkManager.protocol != EnumProtocol.PLAY ||
+                    packet instanceof PacketPlayOutKeepAlive ||
+                    packet instanceof PacketPlayOutChat ||
+                    packet instanceof PacketPlayOutTabComplete ||
+                    packet instanceof PacketPlayOutTitle;
+        }
+    }
+    // PandaSpigot end
+
+    public void handle(Packet packet) {
+        // PandaSpigot start
+        this.a(packet, null, null);
+        // PandaSpigot end
 
     }
 
-    public void a(Packet packet, GenericFutureListener<? extends Future<? super Void>> genericfuturelistener, GenericFutureListener<? extends Future<? super Void>>... agenericfuturelistener) {
-        if (this.g()) {
-            this.m();
-            this.a(packet, (GenericFutureListener[]) ArrayUtils.add(agenericfuturelistener, 0, genericfuturelistener));
+    public void a(Packet packet, GenericFutureListener<? extends Future<? super Void>> genericfuturelistener, GenericFutureListener<? extends Future<? super Void>>[] agenericfuturelistener) {
+        // PandaSpigot start - handle oversized packets better
+        GenericFutureListener<? extends Future<? super Void>>[] listeners = null;
+        if (genericfuturelistener != null || agenericfuturelistener != null) { // cannot call ArrayUtils.add with both null arguments
+            listeners = ArrayUtils.add(agenericfuturelistener, 0, genericfuturelistener);
+        }
+    
+        boolean connected = this.isConnected();
+        if (!connected && !this.preparing) {
+            return; // Do nothing
+        }
+        packet.onPacketDispatch(getPlayer());
+        if (connected && (InnerUtil.canSendImmediate(this, packet) || (
+                MinecraftServer.getServer().isMainThread() && packet.isReady() && this.i.isEmpty() &&
+                        (packet.getExtraPackets() == null || packet.getExtraPackets().isEmpty())
+        ))) {
+            this.writePacket(packet, listeners,null);
+            return;
+        }
+        // write the packets to the queue, then flush - antixray hooks there already
+        java.util.List<Packet> extraPackets = InnerUtil.buildExtraPackets(packet);
+        boolean hasExtraPackets = extraPackets != null && !extraPackets.isEmpty();
+        if (!hasExtraPackets) {
+            this.i.add(new NetworkManager.QueuedPacket(packet, listeners));
         } else {
-            this.j.writeLock().lock();
-
-            try {
-                this.i.add(new NetworkManager.QueuedPacket(packet, (GenericFutureListener[]) ArrayUtils.add(agenericfuturelistener, 0, genericfuturelistener)));
-            } finally {
-                this.j.writeLock().unlock();
+            java.util.List<NetworkManager.QueuedPacket> packets = new java.util.ArrayList<>(1 + extraPackets.size());
+            packets.add(new NetworkManager.QueuedPacket(packet, (GenericFutureListener<? extends Future<? super Void>>[]) null)); // delay the future listener until the end of the extra packets
+        
+            for (int i = 0, len = extraPackets.size(); i < len;) {
+                Packet extra = extraPackets.get(i);
+                boolean end = ++i == len;
+                packets.add(new NetworkManager.QueuedPacket(extra, end ? listeners : null)); // append listener to the end
             }
+        
+            this.i.addAll(packets); // atomic
         }
-
+        this.sendPacketQueue();
+        // PandaSpigot end
     }
-
+    
+    private void dispatchPacket(Packet<?> packet, final GenericFutureListener<? extends Future<? super Void>>[] agenericfuturelistener) { this.a(packet, agenericfuturelistener); } // PandaSpigot - OBFHELPER
     private void a(final Packet packet, final GenericFutureListener<? extends Future<? super Void>>[] agenericfuturelistener) {
         final EnumProtocol enumprotocol = EnumProtocol.a(packet);
         final EnumProtocol enumprotocol1 = (EnumProtocol) this.channel.attr(NetworkManager.c).get();
@@ -177,18 +237,38 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
             this.channel.config().setAutoRead(false);
         }
 
+        EntityPlayer player = getPlayer(); // PandaSpigot
         if (this.channel.eventLoop().inEventLoop()) {
             if (enumprotocol != enumprotocol1) {
                 this.a(enumprotocol);
             }
+            // PandaSpigot start
+            if (!isConnected()) {
+                packet.onPacketDispatchFinish(player, null);
+                return;
+            }
+            try {
+                // PandaSpigot end
 
             ChannelFuture channelfuture = this.channel.writeAndFlush(packet);
 
             if (agenericfuturelistener != null) {
                 channelfuture.addListeners(agenericfuturelistener);
             }
+            // PandaSpigot start
+            if (packet.hasFinishListener()) {
+                channelfuture.addListener((ChannelFutureListener) channelFuture -> packet.onPacketDispatchFinish(player, channelFuture));
+            }
+            // PandaSpigot end
 
             channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+            // PandaSpigot start
+            } catch (Exception e) {
+                g.error("NetworkException: " + player, e);
+                close(new ChatMessage("disconnect.genericReason", "Internal Exception: " + e.getMessage()));;
+                packet.onPacketDispatchFinish(player, null);
+            }
+            // PandaSpigot end
         } else {
             this.channel.eventLoop().execute(new Runnable() {
                 public void run() {
@@ -196,35 +276,76 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
                         NetworkManager.this.a(enumprotocol);
                     }
 
+                    // PandaSpigot start
+                    if (!isConnected()) {
+                        packet.onPacketDispatchFinish(player, null);
+                        return;
+                    }
+                    try {
+                        // PandaSpigot end
                     ChannelFuture channelfuture = NetworkManager.this.channel.writeAndFlush(packet);
 
                     if (agenericfuturelistener != null) {
                         channelfuture.addListeners(agenericfuturelistener);
                     }
+                    // PandaSpigot start
+                    if (packet.hasFinishListener()) {
+                        channelfuture.addListener((ChannelFutureListener) channelFuture -> packet.onPacketDispatchFinish(player, channelFuture));
+                    }
+                    // PandaSpigot end
 
                     channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+                    // PandaSpigot start
+                    } catch (Exception e) {
+                        g.error("NetworkException: " + player, e);
+                        close(new ChatMessage("disconnect.genericReason", "Internal Exception: " + e.getMessage()));;
+                        packet.onPacketDispatchFinish(player, null);
+                    }
+                    // PandaSpigot end
                 }
             });
         }
 
     }
 
-    private void m() {
-        if (this.channel != null && this.channel.isOpen()) {
-            this.j.readLock().lock();
-
-            try {
-                while (!this.i.isEmpty()) {
-                    NetworkManager.QueuedPacket networkmanager_queuedpacket = (NetworkManager.QueuedPacket) this.i.poll();
-
-                    this.a(networkmanager_queuedpacket.a, networkmanager_queuedpacket.b);
-                }
-            } finally {
-                this.j.readLock().unlock();
+    // PandaSpigot start - rewrite this to be safer if ran off main thread
+    private boolean sendPacketQueue() { return this.m(); } // PandaSpigot - OBFHELPER // void -> boolean
+    private boolean m() {
+        if (!this.isConnected()) {
+            return true;
+        }
+        if (MinecraftServer.getServer().isMainThread()) {
+            return this.processQueue();
+        } else if (this.isPending) {
+            // Should only happen during login/status stages
+            synchronized (this.i) {
+                return this.processQueue();
+            }
+        }
+        return false;
+    }
+    private boolean processQueue() {
+        if (this.i.isEmpty()) return true;
+        // If we are on main, we are safe here in that nothing else should be processing queue off main anymore
+        // But if we are not on main due to login/status, the parent is synchronized on packetQueue
+        java.util.Iterator<QueuedPacket> iterator = this.i.iterator();
+        while (iterator.hasNext()) {
+            NetworkManager.QueuedPacket queued = iterator.next(); // poll -> peek
+    
+            // Fix NPE (Spigot bug caused by handleDisconnection())
+            if (false && queued == null) return true;
+    
+            Packet<?> packet = queued.getPacket();
+            if (!packet.isReady()) {
+                return false;
+            } else {
+                iterator.remove();
+                this.dispatchPacket(packet, queued.getGenericFutureListeners());
             }
-
         }
+        return true;
     }
+    // PandaSpigot end
 
     public void a() {
         this.m();
@@ -239,9 +360,22 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         return this.l;
     }
 
+    // PandaSpigot start
+    public void clearPacketQueue() {
+        EntityPlayer player = getPlayer();
+        this.i.forEach(queuedPacket -> {
+            Packet<?> packet = queuedPacket.getPacket();
+            if (packet.hasFinishListener()) {
+                packet.onPacketDispatchFinish(player, null);
+            }
+        });
+        this.i.clear();
+    }
+    // PandaSpigot end
     public void close(IChatBaseComponent ichatbasecomponent) {
         // Spigot Start
         this.preparing = false;
+        this.clearPacketQueue(); // PandaSpigot
         // Spigot End
         if (this.channel.isOpen()) {
             this.channel.close(); // We can't wait as this may be called from an event loop.
@@ -260,6 +394,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         this.channel.pipeline().addBefore("prepender", "encrypt", new PacketEncrypter(MinecraftEncryption.a(1, secretkey)));
     }
 
+    public boolean isConnected() { return this.g(); } // PandaSpigot - OBFHELPER
     public boolean g() {
         return this.channel != null && this.channel.isOpen();
     }
@@ -314,9 +449,9 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
                 } else if (this.getPacketListener() != null) {
                     this.getPacketListener().a(new ChatComponentText("Disconnected"));
                 }
-                this.i.clear(); // Free up packet queue.
+                this.clearPacketQueue(); // PandaSpigot
             } else {
-                NetworkManager.g.warn("handleDisconnection() called twice");
+                //NetworkManager.g.warn("handleDisconnection() called twice"); // PandaSpigot - Do not log useless message
             }
 
         }
@@ -335,6 +470,8 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
             this.a = packet;
             this.b = agenericfuturelistener;
         }
+        public Packet getPacket() { return this.a; } // PandaSpigot - OBFHELPER
+        public GenericFutureListener<? extends Future<? super Void>>[] getGenericFutureListeners() { return this.b; } // PandaSpigot - OBFHELPER
     }
 
     // Spigot Start
diff --git a/src/main/java/net/minecraft/server/Packet.java b/src/main/java/net/minecraft/server/Packet.java
index fdc142b75b78289f01a9e9fed6f36432624735db..d60ec06b995eb477b555d222e99e208560656cef 100644
--- a/src/main/java/net/minecraft/server/Packet.java
+++ b/src/main/java/net/minecraft/server/Packet.java
@@ -9,4 +9,37 @@ public interface Packet<T extends PacketListener> {
     void b(PacketDataSerializer packetdataserializer) throws IOException;
 
     void a(T t0);
+    
+    // PandaSpigot start
+    /**
+     * @param player {@code null} if not at {@link EnumProtocol#PLAY} yet.
+     */
+    default void onPacketDispatch(EntityPlayer player) {}
+    
+    /**
+     * @param player {@code null} if not at {@link EnumProtocol#PLAY} yet.
+     * @param future Can be {@code null} if packet was cancelled.
+     */
+    default void onPacketDispatchFinish(EntityPlayer player, io.netty.channel.ChannelFuture future) {}
+    
+    /**
+     * @return Whether {@link #onPacketDispatchFinish(EntityPlayer, io.netty.channel.ChannelFuture)} should
+     * be called after this packet has been dispatched.
+     */
+    default boolean hasFinishListener() { return false; }
+    
+    /**
+     * Checks whether this packet is ready to be sent.
+     * <p>
+     * If this returns {@code false}, the packet will be added to the queue, and checked every tick until it is ready.
+     *
+     * @return Whether this packet is ready.
+     */
+    default boolean isReady() { return true; }
+    
+    /**
+     * @return A list of extra packets to be sent after this packet.
+     */
+    default java.util.List<Packet<?>> getExtraPackets() { return null; }
+    // PandaSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/ServerConnection.java b/src/main/java/net/minecraft/server/ServerConnection.java
index 578d03ead09c3c126fcd2da0657e1d94dbba9840..f118ba3eaec0948e838281c9608f0a45e753ded1 100644
--- a/src/main/java/net/minecraft/server/ServerConnection.java
+++ b/src/main/java/net/minecraft/server/ServerConnection.java
@@ -61,6 +61,7 @@ public class ServerConnection {
     public volatile boolean d;
     private final List<ChannelFuture> g = Collections.synchronizedList(Lists.<ChannelFuture>newArrayList());
     private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());
+    private static final boolean disableFlushConsolidation = Boolean.getBoolean("Paper.disableFlushConsolidate"); // PandaSpigot
 
     public ServerConnection(MinecraftServer minecraftserver) {
         this.f = minecraftserver;
@@ -103,11 +104,13 @@ public class ServerConnection {
                         ;
                     }
 
+                    if (!disableFlushConsolidation) channel.pipeline().addFirst(new io.netty.handler.flush.FlushConsolidationHandler()); // PandaSpigot
                     channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("legacy_query", new LegacyPingHandler(ServerConnection.this)).addLast("splitter", new PacketSplitter()).addLast("decoder", new PacketDecoder(EnumProtocolDirection.SERVERBOUND)).addLast("prepender", new PacketPrepender()).addLast("encoder", new PacketEncoder(EnumProtocolDirection.CLIENTBOUND));
                     NetworkManager networkmanager = new NetworkManager(EnumProtocolDirection.SERVERBOUND);
 
                     ServerConnection.this.h.add(networkmanager);
                     channel.pipeline().addLast("packet_handler", networkmanager);
+                    networkmanager.isPending = false; // PandaSpigot
                     networkmanager.a((PacketListener) (new HandshakeListener(ServerConnection.this.f, networkmanager)));
                 }
             }).group((EventLoopGroup) lazyinitvar.c()).localAddress(address)).bind().syncUninterruptibly()); // PandaSpigot - Unix domain socket support
