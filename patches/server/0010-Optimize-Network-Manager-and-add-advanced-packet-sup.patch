From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: uRyanxD <familiarodrigues123ro@gmail.com>
Date: Sun, 16 Apr 2023 22:16:41 -0300
Subject: [PATCH] Optimize Network Manager and add advanced packet support


diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 8f8b9aa731f2c97a3e32369bfd4d641a1f2ab412..d5487c0a20b13c9dd9e41435b0707e1ef973ee60 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -62,7 +62,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     };
     private final EnumProtocolDirection h;
     private final Queue<NetworkManager.QueuedPacket> i = Queues.newConcurrentLinkedQueue();
-    private final ReentrantReadWriteLock j = new ReentrantReadWriteLock();
+    // private final ReentrantReadWriteLock j = new ReentrantReadWriteLock();
     public Channel channel;
     // Spigot Start // PAIL
     public SocketAddress l;
@@ -75,6 +75,9 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     private boolean o;
     private boolean p;
     private static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush"); // PandaSpigot - Disable explicit flushing
+    boolean isPending = true;
+    boolean queueImmunity = false;
+    EnumProtocol protocol;
 
     public NetworkManager(EnumProtocolDirection enumprotocoldirection) {
         this.h = enumprotocoldirection;
@@ -97,6 +100,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     }
 
     public void a(EnumProtocol enumprotocol) {
+        protocol = enumprotocol;
         this.channel.attr(NetworkManager.c).set(enumprotocol);
         this.channel.config().setAutoRead(true);
         NetworkManager.g.debug("Enabled auto read");
@@ -136,6 +140,44 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         this.m = packetlistener;
     }
 
+    EntityPlayer getPlayer() {
+        if (m instanceof PlayerConnection) {
+            return ((PlayerConnection) m).player;
+        } else {
+            return null;
+        }
+    }
+    private static class InnerUtil {
+        private static java.util.List<Packet> buildExtraPackets(Packet packet) {
+            java.util.List<Packet> extra = packet.getExtraPackets();
+            if (extra == null || extra.isEmpty()) {
+                return null;
+            }
+            java.util.List<Packet> ret = new java.util.ArrayList<>(1 + extra.size());
+            buildExtraPackets0(extra, ret);
+            return ret;
+        }
+
+        private static void buildExtraPackets0(java.util.List<Packet> extraPackets, java.util.List<Packet> into) {
+            for (Packet extra : extraPackets) {
+                into.add(extra);
+                java.util.List<Packet> extraExtra = extra.getExtraPackets();
+                if (extraExtra != null && !extraExtra.isEmpty()) {
+                    buildExtraPackets0(extraExtra, into);
+                    }
+                }
+        }
+
+        private static boolean canSendImmediate(NetworkManager networkManager, Packet<?> packet) {
+            return networkManager.isPending || networkManager.protocol != EnumProtocol.PLAY || networkManager.queueImmunity ||
+                packet instanceof PacketPlayOutKeepAlive ||
+                packet instanceof PacketPlayOutChat ||
+                packet instanceof PacketPlayOutTabComplete;
+        }
+    }
+
+    // TODO: ADAPT
+    /*
     public void handle(Packet packet) {
         if (this.g()) {
             this.m();
@@ -166,8 +208,42 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
             }
         }
 
+    }*/
+
+    public void a(Packet<?> packet, GenericFutureListener<? extends Future<? super Void>> genericfuturelistener) {
+        boolean connected = this.isConnected();
+        if (!connected && !preparing) {
+            return; // Do nothing
+        }
+        packet.onPacketDispatch(getPlayer());
+        if (connected && (InnerUtil.canSendImmediate(this, packet) || (
+            MinecraftServer.getServer().isMainThread() && packet.isReady() && this.i.isEmpty() &&
+            (packet.getExtraPackets() == null || packet.getExtraPackets().isEmpty())
+        ))) {
+            this.dispatchPacket(packet, genericfuturelistener);
+            return;
+        }
+        java.util.List<Packet> extraPackets = InnerUtil.buildExtraPackets(packet);
+        boolean hasExtraPackets = extraPackets != null && !extraPackets.isEmpty();
+        if (!hasExtraPackets) {
+            this.i.add(new NetworkManager.QueuedPacket(packet, genericfuturelistener));
+        } else {
+            java.util.List<NetworkManager.QueuedPacket> packets = new java.util.ArrayList<>(1 + extraPackets.size());
+            packets.add(new NetworkManager.QueuedPacket(packet, null));
+
+            for (int i = 0, len = extraPackets.size(); i < len;) {
+                Packet extra = extraPackets.get(i);
+                boolean end = ++i == len;
+                packets.add(new NetworkManager.QueuedPacket(extra, end ? genericfuturelistener : null));
+            }
+
+            this.i.addAll(packets); // atomic
+        }
+
+        this.sendPacketQueue();
     }
 
+    private void dispatchPacket(Packet<?> packet, GenericFutureListener<? extends Future<? super Void>>[] agenericFutureListener) { this.a(packet, agenericFutureListener); } // PandaSpigot - OBFHELPER
     private void a(final Packet packet, final GenericFutureListener<? extends Future<? super Void>>[] agenericfuturelistener) {
         final EnumProtocol enumprotocol = EnumProtocol.a(packet);
         final EnumProtocol enumprotocol1 = (EnumProtocol) this.channel.attr(NetworkManager.c).get();
@@ -177,38 +253,67 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
             this.channel.config().setAutoRead(false);
         }
 
+        EntityPlayer player = getPlayer(); // PandaSpigot
         if (this.channel.eventLoop().inEventLoop()) {
             if (enumprotocol != enumprotocol1) {
                 this.a(enumprotocol);
             }
+            if (!isConnected()) {
+                packet.onPacketDispatchFinish(player, null);
+                return;
+            }
+            try {
 
             ChannelFuture channelfuture = this.channel.writeAndFlush(packet);
 
             if (agenericfuturelistener != null) {
                 channelfuture.addListeners(agenericfuturelistener);
             }
+            if (packet.hasFinishListener()) {
+                channelfuture.addListener((ChannelFutureListener) channelFuture -> packet.onPacketDispatchFinish(player, ChannelFuture));
+            }
 
             channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+            } catch (Exception e) {
+                g.error("NetworkException: " + player, e);
+                close(new ChatMessage("disconnect.genericReason", "Internal Exception" + e.getMessage()));;
+                packet.onPacketDispatchFinish(player, null);
+            }
         } else {
             this.channel.eventLoop().execute(new Runnable() {
                 public void run() {
                     if (enumprotocol != enumprotocol1) {
                         NetworkManager.this.a(enumprotocol);
                     }
+                    if (!isConnected()) {
+                        packet.onPacketDispatchFinish(player, null);
+                        return;
+                    }
+                    try {
 
                     ChannelFuture channelfuture = NetworkManager.this.channel.writeAndFlush(packet);
 
                     if (agenericfuturelistener != null) {
                         channelfuture.addListeners(agenericfuturelistener);
                     }
+                    if (packet.hasFinishListener()) {
+                        channelfuture.addListener((ChannelFutureListener) channelFuture -> packet.onPacketDispatchFinish(player, ChannelFuture));
+                    }
 
                     channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+                    } catch (Exception e) {
+                        g.error("NetworkException: " + player, e);
+                        close(new ChatMessage("disconnect.genericReason", "Internal Exception" + e.getMessage()));;
+                        packet.onPacketDispatchFinish(player, null);
+                    }
                 }
             });
         }
 
     }
 
+    private boolean sendPacketQueue() { return this.m(); }
+    /*
     private void m() {
         if (this.channel != null && this.channel.isOpen()) {
             this.j.readLock().lock();
@@ -225,6 +330,40 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
 
         }
     }
+    */
+    private boolean m() {
+        if (!isConnected()) {
+            return true;
+        }
+        if (MinecraftServer.getServer().isMainThread()) {
+            return processQueue();
+        } else if (isPending()) {
+            synchronized (this.i) {
+                return this.processQueue();
+            }
+        }
+        return false;
+    }
+    private boolean processQueue() {
+        if (this.i.isEmpty()) return true;
+        java.util.Iterator<QueuedPacket> iterator = this.i.iterator();
+        while (iterator.hasNext()) {
+            NetworkManager.QueuedPacket queued = iterator.next();
+
+            if (queued == null) {
+                return true;
+            }
+
+            Packet<?> packet = queued.getPacket();
+            if (!packet.isReady()) {
+                return false;
+            } else {
+                iterator.remove();
+                this.dispatchPacket(packet, queued.getGenericFutureListener());
+            }
+        }
+        return true;
+    }
 
     public void a() {
         this.m();
@@ -239,9 +378,21 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         return this.l;
     }
 
+    public void clearPacketQueue() {
+        EntityPlayer player = getPlayer();
+        i.forEach(queuedPacket -> {
+            Packet<?> packet = queuedPacket.getPacket();
+            if (packet.hasFinishListener()) {
+                packet.onPacketDispatchFinish(player, null);
+            }
+        });
+        i.clear();
+    }
+
     public void close(IChatBaseComponent ichatbasecomponent) {
         // Spigot Start
         this.preparing = false;
+        clearPacketQueue();
         // Spigot End
         if (this.channel.isOpen()) {
             this.channel.close(); // We can't wait as this may be called from an event loop.
@@ -260,6 +411,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         this.channel.pipeline().addBefore("prepender", "encrypt", new PacketEncrypter(MinecraftEncryption.a(1, secretkey)));
     }
 
+    public boolean isConnected() { return this.g(); }
     public boolean g() {
         return this.channel != null && this.channel.isOpen();
     }
@@ -314,9 +466,9 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
                 } else if (this.getPacketListener() != null) {
                     this.getPacketListener().a(new ChatComponentText("Disconnected"));
                 }
-                this.i.clear(); // Free up packet queue.
+                this.clearPacketQueue(); // Free up packet queue.
             } else {
-                NetworkManager.g.warn("handleDisconnection() called twice");
+                // NetworkManager.g.warn("handleDisconnection() called twice");
             }
 
         }
@@ -328,8 +480,8 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
 
     static class QueuedPacket {
 
-        private final Packet a;
-        private final GenericFutureListener<? extends Future<? super Void>>[] b;
+        private final Packet a; private final Packet<?> getPacket() { return this.a; }
+        private final GenericFutureListener<? extends Future<? super Void>>[] b; private final GenericFutureListener<? extends Future<? super Void>>[] getGenericFutureListener() { return this.b; }
 
         public QueuedPacket(Packet packet, GenericFutureListener<? extends Future<? super Void>>... agenericfuturelistener) {
             this.a = packet;
diff --git a/src/main/java/net/minecraft/server/Packet.java b/src/main/java/net/minecraft/server/Packet.java
index fdc142b75b78289f01a9e9fed6f36432624735db..f60249cc95578f04a722f7b4d8cbb57f2f77ae3d 100644
--- a/src/main/java/net/minecraft/server/Packet.java
+++ b/src/main/java/net/minecraft/server/Packet.java
@@ -9,4 +9,19 @@ public interface Packet<T extends PacketListener> {
     void b(PacketDataSerializer packetdataserializer) throws IOException;
 
     void a(T t0);
+
+    /**
+     * @param player Null if not at PLAY stage yet
+     */
+    default void onPacketDispatch(@javax.annotation.Nullable EntityPlayer player) {}
+
+    /**
+     * @param player Null if not at PLAY stage yet
+     * @param future Can be null if packet was cancelled
+     */
+    default void onPacketDispatchFinish(@javax.annotation.Nullable EntityPlayer player, @javax.annotation.Nullable io.netty.channel.ChannelFuture future) {}
+    default boolean hasFinishListener() { return false; }
+    default boolean isReady() { return true; }
+    default java.util.List<Packet> getExtraPackets() { return null; }
+
 }
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 3c2d3197faa7e5212f7c6f9970e56426ae02ade7..411a6380c83549f6b387346406d878ad8e046765 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -145,6 +145,7 @@ public abstract class PlayerList {
         this.a(entityplayer, (EntityPlayer) null, worldserver);
         PlayerConnection playerconnection = new PlayerConnection(this.server, networkmanager, entityplayer);
 
+        networkmanager.queueImmunity = true;
         playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimension(), worldserver.getDifficulty(), Math.min(this.getMaxPlayers(), 60), worlddata.getType(), worldserver.getGameRules().getBoolean("reducedDebugInfo"))); // CraftBukkit - cap player list to 60
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload("MC|Brand", (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
@@ -152,6 +153,7 @@ public abstract class PlayerList {
         playerconnection.sendPacket(new PacketPlayOutSpawnPosition(blockposition));
         playerconnection.sendPacket(new PacketPlayOutAbilities(entityplayer.abilities));
         playerconnection.sendPacket(new PacketPlayOutHeldItemSlot(entityplayer.inventory.itemInHandIndex));
+        networkmanager.queueImmunity = false;
         entityplayer.getStatisticManager().d();
         entityplayer.getStatisticManager().updateStatistics(entityplayer);
         this.sendScoreboard((ScoreboardServer) worldserver.getScoreboard(), entityplayer);
diff --git a/src/main/java/net/minecraft/server/ServerConnection.java b/src/main/java/net/minecraft/server/ServerConnection.java
index 578d03ead09c3c126fcd2da0657e1d94dbba9840..cc8bc4226e1822131d2ed56b3de7aa4fda9a34d8 100644
--- a/src/main/java/net/minecraft/server/ServerConnection.java
+++ b/src/main/java/net/minecraft/server/ServerConnection.java
@@ -61,6 +61,7 @@ public class ServerConnection {
     public volatile boolean d;
     private final List<ChannelFuture> g = Collections.synchronizedList(Lists.<ChannelFuture>newArrayList());
     private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());
+    private static final boolean disableFlushConsolidation = Boolean.getBoolean("Paper.disableFlushConsolidate");
 
     public ServerConnection(MinecraftServer minecraftserver) {
         this.f = minecraftserver;
@@ -103,11 +104,13 @@ public class ServerConnection {
                         ;
                     }
 
+                    if (!disableFlushConsolidation) channel.pipeline().addFirst(new io.netty.handler.flush.FlushConsolidationHandler());
                     channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("legacy_query", new LegacyPingHandler(ServerConnection.this)).addLast("splitter", new PacketSplitter()).addLast("decoder", new PacketDecoder(EnumProtocolDirection.SERVERBOUND)).addLast("prepender", new PacketPrepender()).addLast("encoder", new PacketEncoder(EnumProtocolDirection.CLIENTBOUND));
                     NetworkManager networkmanager = new NetworkManager(EnumProtocolDirection.SERVERBOUND);
 
                     ServerConnection.this.h.add(networkmanager);
                     channel.pipeline().addLast("packet_handler", networkmanager);
+                    networkmanager.isPending = false;
                     networkmanager.a((PacketListener) (new HandshakeListener(ServerConnection.this.f, networkmanager)));
                 }
             }).group((EventLoopGroup) lazyinitvar.c()).localAddress(address)).bind().syncUninterruptibly()); // PandaSpigot - Unix domain socket support
